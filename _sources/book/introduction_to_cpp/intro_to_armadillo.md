(sec:intro_to_armadillo)=
# Introduction to Armadillo

Armadillo is an efficient linear algebra library for C++ users. Its aim is to provide a library that balances speed and ease of use. We recommend this library for numerical computations as a replacement for dynamic allocation of arrays.

We'll cover the very basics here to get you started with the library. However, their webpage provide an excellent, detailed [code documentation](http://arma.sourceforge.net/docs.html) with examples of usage that you can search through.

## Building code with Armadillo

We must make sure to include the header file for Armadillo, which amounts to adding `#include <armadillo>` at the top of a header or source file.

### Compiling code with Armadillo
For macOS users specifically, you must specificy a version of C++ that is C++11 or later. This is done by adding the compiler flag `-std=c++11` during compilation.

For Linux users, nothing special is typically required.


### Linking code with Armadillo

To link to Armadillo, we must add the compiler flag `-larmadillo` during linking.

## Vectors

Armadillo provides a useful vector class `arma::vec` that can be used to replace arrays in numerical computations. Assume `n` is a positive integer.

### Declaring and filling vectors

```c++
arma::vec x = arma::vec(n); //Initialize vector but don't fill.
arma::vec y = arma::vec(n).fill(2.); //Declare and fill with 2's.
arma::vec z = arma::vec(n).randu(); //Declare and will with random uniform values.
```

### Accessing and assigning elements in a vector

We can access an element `i` from a vector `x` by

```c++
double x_i = x(i); //Extract element i of x and assign it to x_i.
```

We can assign a new value to element `i` in the vector `x` using

```c++
x(i) = some_new_value;
```

## Matrices
Assume that `n` and `m` are positive integers.


### Declaring and filling matrices

Creating matrices with Armadillo is easy. Here's a couple examples:

```c++
arma::mat A = arma::mat(n, m); //Initialize but don't fill
arma::mat B = arma::mat(n, m).fill(0.); //Declare and fill with zeros.
arma::mat C = arma::mat(n, m).randn(); //Declare and fill with random values from the normal distribution.
```

### Accessing elements in a matrix

Access of elements in an Armadillo matrix is done as follows:

```c++
double A_ij = A(i,j); //Assign element (i,j) of the matrix A to A_ij.
```

### Extracting a column of a matrix

Armadillo provides a simple way to extract entire columns of a matrix:

```c++
arma::vec col_vec = A.col(j); //Extract column j of A and assign it to col_vec.
```


## Saving and loading vectors and matrices

Armadillo provides built-in functionality for saving and loading `arma::vec` and `arma::mat` objects to binary files.
Not only does this simplify storage of results with a predictable format, but it turns out that they provide a Python module `pyarma` that can me used to load in these objects directly into a Python program!

If `A` is an `arma::mat` object, you can save it using

```c++
A.save(filename);
```

The default storage format is binary. Your filename should end with `.bin`. Loading the object is as simple as

```c++
B = arma::mat() //Initialize an arma::mat variable
B.load(filename) //Load content of arma::mat A stored earlier into arma::mat B.
```

### Reading a data table in text format

The `load` functionality in Armadillo can also be used to load data from files not generated by Armadillo, as long as the data file has some standard format (see the Armadillo documentation for details). For instance, assume we have a text file `mynumbers.dat` looking like this:

```terminal
0.0000e+00  0.0000e+00  0.0000e+00
0.0000e+00  1.9635e-01  3.8553e-02
0.0000e+00  3.9270e-01  1.5421e-01
0.0000e+00  5.8905e-01  3.4698e-01
0.0000e+00  7.8540e-01  6.1685e-01
1.9635e-01  0.0000e+00  1.9635e-01
1.9635e-01  1.9635e-01  2.4247e-01
1.9635e-01  3.9270e-01  3.6569e-01
1.9635e-01  5.8905e-01  5.6599e-01
1.9635e-01  7.8540e-01  8.4336e-01
3.9270e-01  0.0000e+00  3.9270e-01
3.9270e-01  1.9635e-01  4.6150e-01
3.9270e-01  3.9270e-01  6.0723e-01
3.9270e-01  5.8905e-01  8.2971e-01
3.9270e-01  7.8540e-01  1.1288e+00
5.8905e-01  0.0000e+00  5.8905e-01
5.8905e-01  1.9635e-01  6.9558e-01
5.8905e-01  3.9270e-01  8.7831e-01
5.8905e-01  5.8905e-01  1.1363e+00
5.8905e-01  7.8540e-01  1.4688e+00
```

To read these numbers into an Armadillo matrix we simply do this:

```c++
arma::mat A;
A.load("mynumbers.dat", arma::raw_ascii)
```


### The Python module

You can install the Armadillo Python module `pyarma` using

```sh
pip install pyarma
```

The recommended way to import the library in Python is

```python
import pyarma as pa
```

From there you can easily load the `arma::mat` (or `arma::vec`) object you saved in C++ using

```python
A = pa.mat() #Create pa.mat object (just as arma::mat in C++)
A.load(filename) #Load the content of the matrix you saved into your Python program.
```
